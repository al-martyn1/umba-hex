---
Title: Утилита Umba HEX
---

# Краткое описание возможностей утилиты Umba HEX

**Важно:** Утилита **Umba HEX** в текущий момент не реализована в виде самостоятельного инструмента,
весь функционал содержится в нескольких взаимосвязанных библиотеках. Краткое описание возможностей утилиты
основано на моём представлении о её функционале и возможностях, реализованных в библиотеках. Все примеры
взяты из различных тестов этих библиотек.


Утилита **Umba HEX** предназначена для:

- описания каких-либо двоичных структур или пакетов;
- описания фиксированных частей раскладок HEX-файлов прошивок микроконтроллеров.


Утилита **Umba HEX** умеет:

- генерировать код на C/C++ для использования в коде для обращения к полям пакета/фиксированной части раскладки HEX-файла;
- генерировать графические диаграммы для использования в документации;
- заполнять HEX-файлы заданными значениями.
- при заполнении HEX-файлов утилита **Umba HEX** умеет самостоятельно расчитывать CRC 8/16/32 предыдущей части пакета 
  согласно заданным `poly` и `seed` в опциях поля.


# Синтаксис описания диаграмм

Синтаксис описания диаграмм основан на синтаксисе диаграмм [mermaid packet diagram](https://mermaid.js.org/syntax/packet.html), 
с некоторыми расширениями:

- в `mermaid packet diagram`-ах последовательность символов `%%` начинает однострочный коментарий. 
  В расширении `Umba HEX` коментарий начинается так же, но последовательность `%%#!` начинает 
  директивы расширения;

- `mermaid packet diagram` оперирует битами, `Umba HEX` позволяет оперировать байтами. 
  Для этого после указания типа `mermaid` диаграммы (для `packet diagram`) идентификатором `packet-beta`
  добавляем расширение: `packet-beta %%#! byte-diagram`. Для битовых диаграмм ничего не добавляем или указываем
  `packet-beta %%#! bit-diagram`;

- позволяет использовать не только диапазоны, но и привычные программистам типы `int/uint8/16/32` и `char`, при этом 
  поля будут иметь соответствующий размер в байтах;

- позволяет использовать массивы: `char[16] : "Name" %%#! ascii-z`;

- глобальные расширенные директивы начинаются со специального коментария в начале строки:
    - `%%#! native le data 32 bits segment 16 bits segment-shift 4 bits offset 16 bits` - описание 'нативной' платформы;
    - `%%#! display-options byte-numbers no-single-byte-numbers` - флаги, управляющие отображением диаграммы;
    - `%%#! display-width 16` - количество байт, отображаемых на одной строке диаграммы, 8/16/32/64.

- опции отдельных полей задаются после их описания в той же строке  после расширенного коментария `%%#!`;

- опциями отдельных полей могут быть следующие опции: 
  `ascii-z` - массив/строка, заканчивающаяся нулем - если поле заполнено целиком, нули остутствуют, иначе 
  неинициализированные байты заполняются нулями (**примечание:** тут надо вспомнить - весьма вероятно, что 
  завершающий ноль гарантируется, тогда значимых байт/символов хранится на один меньше); `block` - не помню,
  вроде отображение на диаграмме блоком (массивом);
  `le`, `be`, `me-le`, `me-be` - little|big-endian и middle-endian-little|big-endian (обратите внимание
  на индексы байт многобайтных значений на диаграммах);
  `crc`, `poly`, `seed` - CRC-поле и его параметры.

**Важно:** синтаксис `+1: "Block name"` для задания количества бит/байт в текущий момент не поддерживается
(что-то я профакапил, или, что тоже вероятно, эта фича в mermaid добавлена уже после того, как я делал свою реализацию).



# Пример описания протокола обмена

**Примечание 1:** в сгенерированном C/C++ коде для частей пакета есть баг - 
когда у нас в описании пакета только один фрагмент с единственной директивой 
`ORG` или вообще без неё, то должна генерироваться только одна C/C++ структура, 
сейчас генерируется две. 
Это баг, надо разбираться.

**Примечание 2:** на диаграммах также отображаются артефакты, связанные с несколькими
`ORG`-директивами. Это связано с тем, что основное тестирование производилось с прицелом 
на формирование HEX-файлов с несколькими секциями.

**Примечание 3:** пакеты с полями переменной длины пока не поддерживаются, вместо 
них используем какую-либо фиксированную длину. Сгенерированные C/C++ не будут точно 
соответствовать структуре пакета.


## Кадр (Frame)

**Описание кадра**
#!snippet doc.drafts/samples/example-01-1-frame.txt

**Графическая иллюстрация раскладки данных**
![](doc.drafts/samples/example-01-1-frame.svg)

**Сгенерированный C/C++ код**
#!snippet doc.drafts/samples/example-01-1-frame.h


##Заколовок (Header)

**Описание заголовка**
#!snippet doc.drafts/samples/example-01-2-header.txt

**Графическая иллюстрация раскладки данных**
![](doc.drafts/samples/example-01-2-header.svg)

**Сгенерированный C/C++ код**
#!snippet doc.drafts/samples/example-01-2-header.h


##Рабочая нагрузка (Payload)

**Описание рабочей нагрузки**
#!snippet doc.drafts/samples/example-01-3-payload.txt

**Графическая иллюстрация раскладки данных**
![](doc.drafts/samples/example-01-3-payload.svg)

**Сгенерированный C/C++ код**
#!snippet doc.drafts/samples/example-01-3-payload.h



# Пример описания раскладки HEX-файла

В раскладке описывается сегментированный HEX-файл, раскладка описывает
два раздела/фрагмента: "Harware Info" и "Software Info"


## Описание раскладки

#!snippet doc.drafts/samples/example-02.txt

## Диаграмма, 16 байт шириной

![](doc.drafts/samples/example-02-w16.svg)

## Диаграмма, 32 байта шириной

![](doc.drafts/samples/example-02-w32.svg)

## Диаграмма, 64 байт шириной

![](doc.drafts/samples/example-02-w64.svg)

## Сгенерированный C/C++ код

#!snippet doc.drafts/samples/example-02.h


# Генерация HEX-файла и пример пайплайна для производства и разработки

Прошивка в устройстве может состоять из нескольких частей: метаинформация
и собственно, сама исполняемая прошивка. Метаинформация, к примеру, может состоять
из описания аппаратной части и описания программной части.


## Первоначальная прошивка нового устройства на производстве

Метаинформация об аппаратной части зашивается один раз при первоначальной прошивке 
устройства после сборки, туда зашивается актуальная информация о ревизии платы, дате сборки,
номере партии, серийном номере устройства. Для генерации такой информации можно использовать
утилиту **Umba HEX**.

Также в при первоначальной прошивке может зашиваться базовый загрузчик (bootloader), который 
проверяет при  прошивке только метаинформацию об аппаратной части в устройстве и в новой прошивке,
и выдаёт отказ при их несовпадении.

Метаинформацию об аппаратной части можно генерировать в отдельный HEX-файл с последующим объединением 
HEX-файлов загрузчика и метаинформации об аппаратуре, или можно генерировать
в существующий файл (загрузчика).


## Сборка прошивки

При сборке прошивки при помощи утилиты **Umba HEX** генерируется метаинформация по аппаратуре, для которой
собирается прошивка, а также о версии собираемой прошивки.

В прошивке также имеется загрузчик, который проверяет аппаратную версию платы, а также версию прошивки.

Для генерации метаинформации о программной части также может использоваться утилита **Umba HEX**.
При этом эта информация генерируется в готовый файл прошивки, или в отдельные файлы для последующего объединения
сторонними утилитами.

Адреса блоков метаинформации утилитой **Umba HEX** могут выводится в C/C++ файл, описания структур 
метаинформации также выводятся в C/C++ файл, и эти исходные файлы используются при сборке прошивки.
Таким образом загрузчик в прошивке будет знать, где метаинформация расположена во флэш-памяти,
знает её раскладку, и может произвести нужные проверки: не позволить зашить прошивку от платы другой ревизии,
не позволить прошить прошивку с более старой версией firmware или с более старой датой сборки.


## Пример скрипта для формирования HEX-файла по описанию диаграммы

Для генерации HEX-файла утилита **Umba HEX** принимает: 
1. описание раскладки (диаграмму);
2. "скрипт" для задания значений полей.

Имена полей сквозные для всей диаграммы, т.е. они должны быть уникальными для всего файла диаграммы.

В HEX-файл записываются только те поля, которые явно задаются, таким образом, можно в одной диаграмме
описать как метаинформацию об аппаратуре, так и метаинформацию о firmware, но заполнять/генерировать
HEX-файлы по ним по отдельности.

**Пример "скрипта" для формирования HEX-файла**
#!snippet doc.drafts/samples/example-02-values.txt


#/*


# Получение библиотек

Для подключения и использования необходимых библиотек их нужно раскомментировать в файлах:

 - `_libs/_clone_libs.bat`
 - `_libs/_git-job-impl.bat`


# Настройка проекта на базе данного шаблона 

## Настройка CMakeLists.txt

### Название проекта

В начале файла находим строку описания проекта (с директивой `project`):

#!insert{noLineNo,noKeepCutTags,filename,no-path} CMakeLists.txt#`project(umba-template`-(1)

Заменяем название `umba-template` на название проекта.



### Настройка библиотек

Импортируем нужные библиотеки:

#!insert{noLineNo,noKeepCutTags,filename,no-path} CMakeLists.txt#`# Import libraries here`-(1)


Настраиваем списки библиотек для последующего использования:

#!insert{noLineNo,noKeepCutTags,filename,no-path} CMakeLists.txt#`# Configure libraries here`-(1)

При настройке целей можно как использовать заранее подготовленные списки библиотек, так и указывать библиотеки непосредственно.


### Добавление целей

Настраиваем цель (исполняемый файл) проекта:

#!insert{noLineNo,noKeepCutTags,filename,no-path} CMakeLists.txt#`add_executable(umba-template`-(1)

При необходимости дополнительные цели можно добавлять аналогично.


## Настройка запуска MSVC

Для открытия проекта в MSVC нужно настроить название "солюшена":

#!insert{noLineNo,noKeepCutTags,filename,no-path} .set_sln.bat#`@set SLN`-(1)

Это название должно совпадать с тем, что указано в директиве `project` файла `CMakeLists.txt`.


#!insert{doc} .bat/md_/building.md_

#*/
