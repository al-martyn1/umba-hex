---
Title: Утилита Umba HEX
---

# Краткое описание возможностей утилиты Umba HEX

**Важно:** Утилита **Umba HEX** в текущий момент не реализована в виде самостоятельного инструмента,
весь функционал содержится в нескольких взаимосвязанных библиотеках. Краткое описание возможностей утилиты
основано на моём представлении о её функционале и возможностях, реализованных в библиотеках. Все примеры
взяты из различных тестов этих библиотек.


Утилита **Umba HEX** предназначена для:

- описания каких-либо двоичных структур или пакетов;
- описания фиксированных частей раскладок HEX-файлов прошивок микроконтроллеров.


Утилита **Umba HEX** умеет:

- генерировать код на C/C++ для использования в коде для обращения к полям пакета/фиксированной части раскладки HEX-файла;
- генерировать графические диаграммы для использования в документации;
- заполнять HEX-файлы заданными значениями.
- призаполнении HEX-файлов утилита **Umba HEX** умеет самостоятельно расчитывать CRC 8/16/32 предыдущей части пакета 
  согласно заданным `poly` и `seed` в опциях поля.


# Синтаксис описания диаграмм

Синтаксис описания диаграмм основан на синтаксисе диаграмм [mermaid packet diagram](https://mermaid.js.org/syntax/packet.html), 
с некоторыми расширениями:

- в `mermaid packet diagram`-ах последовательность символов `%%` начинает однострочный коментарий. 
  В расширении `Umba HEX` коментарий начинается так же, но последовательность `%%#!` начинает 
  директивы расширения;

- `mermaid packet diagram` оперирует битами, `Umba HEX` позволяет оперировать байтами. 
  Для этого после указания типа `mermaid` диаграммы (для `packet diagram`) идентификатором `packet-beta`
  добавляем расширение: `packet-beta %%#! byte-diagram`. Для битовых диаграмм ничего не добавляем или указываем
  `packet-beta %%#! bit-diagram`;

- позволяет использовать не только диапазоны, но и привычные программистам типы `int/uint8/16/32` и `char`, при этом 
  поля будут иметь соответствующий размер в байтах;

- позволяет использовать массивы: `char[16] : "Name" %%#! ascii-z`;

- глобальные расширенные директивы начинаются со специального коментария в начале строки:
    - `%%#! native le data 32 bits segment 16 bits segment-shift 4 bits offset 16 bits` - описание 'нативной' платформы;
    - `%%#! display-options byte-numbers no-single-byte-numbers` - флаги, управляющие отображением диаграммы;
    - `%%#! display-width 16` - количество байт, отображаемых на одной строке диаграммы, 8/16/32/64.

- опции отдельных полей задаются после их описания в той же строке  после расширенного коментария `%%#!`;

- опциями отдельных полей могут быть следующие опции: 
  `ascii-z` - массив/строка, заканчивающаяся нулем - если поле заполнено целиком, нули остутствуют, иначе неинициализированные байты
  заполняются нулями; `block` - не помню, вроде отображение на диаграмме блоком (массивом);
  `le`, `be`, `me-le`, `me-be` - little|big-endian и middle-endian-little|big-endian (обратите внимание на индексы байт 
  многобайтных значений на диаграммах);
  `crc`, `poly`, `seed` - CRC-поле и его параметры.

**Важно:** синтаксис `+1: "Block name"` для задания количества бит/байт в текущий момент не поддерживается (что-то я профакапил).



# Пример описания протокола

**Примечание 1:** в сгенерированном C/C++ коде для частей пакета есть баг - 
когда у нас в описании пакета только один фрагмент с единственной директивой 
`ORG` или вообще без неё, то должна генерироваться только одна C/C++ структура, 
сейчас генерируется две. 
Это баг, надо разбираться.

**Примечание 2:** на диаграммах также отображаются артефакты, связанные с несколькими
`ORG`-директивами. Это связано с тем, что основное тестирование производилось с прицелом 
на формирование HEX-файлов с несколькими секциями.

**Примечание 3:** пакеты с полями переменной длины пока не поддерживаются, вместо 
них используем какую-либо фиксированную длину. Сгенерированные C/C++ не будут точно 
соответствовать структуре пакета.


## Кадр (Frame)

**Описание кадра**
#!snippet doc.drafts/samples/example-01-1-frame.txt

**Графическая иллюстрация раскладки данных**
![](doc.drafts/samples/example-01-1-frame.svg)

**Сгенерированный C/C++ код**
#!snippet doc.drafts/samples/example-01-1-frame.h


##Заколовок (Header)

**Описание заголовка**
#!snippet doc.drafts/samples/example-01-2-header.txt

**Графическая иллюстрация раскладки данных**
![](doc.drafts/samples/example-01-2-header.svg)

**Сгенерированный C/C++ код**
#!snippet doc.drafts/samples/example-01-2-header.h


##Рабочая нагрузка (Payload)

**Описание рабочей нагрузки**
#!snippet doc.drafts/samples/example-01-3-payload.txt

**Графическая иллюстрация раскладки данных**
![](doc.drafts/samples/example-01-3-payload.svg)

**Сгенерированный C/C++ код**
#!snippet doc.drafts/samples/example-01-3-payload.h



# Пример описания раскладки HEX-файла

В раскладке описывается сенментированный HEX-файл, раскладка описывает
два раздела/фрагмента: "Harware Info" и "Software Info"


## Описание раскладки

#!snippet doc.drafts/samples/example-02.txt

## Диаграмма, 16 байт шириной

![](doc.drafts/samples/example-02-w16.svg)

## Диаграмма, 32 байта шириной

![](doc.drafts/samples/example-02-w32.svg)

## Диаграмма, 64 байт шириной

![](doc.drafts/samples/example-02-w64.svg)

## Сгенерированный C/C++ код

#!snippet doc.drafts/samples/example-02.h


#/*


# Получение библиотек

Для подключения и использования необходимых библиотек их нужно раскомментировать в файлах:

 - `_libs/_clone_libs.bat`
 - `_libs/_git-job-impl.bat`


# Настройка проекта на базе данного шаблона 

## Настройка CMakeLists.txt

### Название проекта

В начале файла находим строку описания проекта (с директивой `project`):

#!insert{noLineNo,noKeepCutTags,filename,no-path} CMakeLists.txt#`project(umba-template`-(1)

Заменяем название `umba-template` на название проекта.



### Настройка библиотек

Импортируем нужные библиотеки:

#!insert{noLineNo,noKeepCutTags,filename,no-path} CMakeLists.txt#`# Import libraries here`-(1)


Настраиваем списки библиотек для последующего использования:

#!insert{noLineNo,noKeepCutTags,filename,no-path} CMakeLists.txt#`# Configure libraries here`-(1)

При настройке целей можно как использовать заранее подготовленные списки библиотек, так и указывать библиотеки непосредственно.


### Добавление целей

Настраиваем цель (исполняемый файл) проекта:

#!insert{noLineNo,noKeepCutTags,filename,no-path} CMakeLists.txt#`add_executable(umba-template`-(1)

При необходимости дополнительные цели можно добавлять аналогично.


## Настройка запуска MSVC

Для открытия проекта в MSVC нужно настроить название "солюшена":

#!insert{noLineNo,noKeepCutTags,filename,no-path} .set_sln.bat#`@set SLN`-(1)

Это название должно совпадать с тем, что указано в директиве `project` файла `CMakeLists.txt`.


#!insert{doc} .bat/md_/building.md_

#*/
